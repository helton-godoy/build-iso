#!/usr/bin/env bash
#
# install-system - Instalador Debian ZFS (Consolidated)
# Debian + ZFS-on-Root + ZFSBootMenu
#
# Unified script to avoid variable scope issues and simplify maintenance.
#

set -euo pipefail

# =============================================================================
# CONSTANTS & CONFIGURATION
# =============================================================================

# Paths
readonly INSTALLER_DIR="/usr/local/bin/installer"
readonly LIB_DIR="${INSTALLER_DIR}/lib"
export LIB_DIR

# Global Configuration (Defaults)
declare PROFILE="${PROFILE:-Server}"
declare POOL_NAME="zroot"
declare MOUNT_POINT="${MOUNT_POINT:-/mnt/target}"
declare RAID_TOPOLOGY=""
declare ASHIFT=12
declare COMPRESSION="zstd"
declare CHECKSUM="on"
declare COPIES=1
declare HDSIZE=""
declare ENCRYPTION="off"
declare ENCRYPTION_PASSPHRASE=""

# User Identity
declare HOSTNAME=""
declare USERNAME=""
declare ROOT_PASS=""
declare USER_PASS=""

# Target Disks (Array)
declare -a SELECTED_DISKS=()

# =============================================================================
# LIBRARY LOADING
# =============================================================================

_load_lib() {
	local lib_path="$1"
	if [[ ! -f ${lib_path} ]]; then
		echo "FATAL: Library not found: ${lib_path}" >&2
		exit 1
	fi
	source "${lib_path}"
}

# Load helper libraries
_load_lib "${LIB_DIR}/logging.sh"
_load_lib "${LIB_DIR}/validation.sh"
_load_lib "${LIB_DIR}/error.sh"
_load_lib "${LIB_DIR}/ui_gum.sh"
_load_lib "${LIB_DIR}/chroot.sh"

# =============================================================================
# PREFLIGHT CHECKS & VALIDATION
# =============================================================================

check_dependencies() {
    log_init_component "Checking Dependencies"

    local cmds=("gum" "wipefs" "sgdisk" "zpool" "zfs" "mkfs.vfat" "efibootmgr" "unsquashfs" "rsync" "dd")
    for cmd in "${cmds[@]}"; do
        if ! command -v "${cmd}" >/dev/null 2>&1; then
            error_exit "Missing required command: ${cmd}. Please install required packages."
        fi
    done

    # Check for MBR binary (for legacy boot)
    if [[ ! -f /usr/lib/syslinux/mbr/gptmbr.bin ]]; then
        log_warn "Legacy boot MBR (gptmbr.bin) not found. Legacy boot installation might fail."
    fi

    log_success "All dependencies found."
}

# =============================================================================
# UTILITY FUNCTIONS
# =============================================================================

get_part_suffix() {
	local disk=$1
	if [[ ${disk} =~ /dev/nvme ]]; then
		echo "p"
	else
		echo ""
	fi
}

umount_disk() {
    local disk=$1
    log_info "Unmounting any existing partitions on ${disk}..."
    
    # Try to unmount everything associated with this disk
    grep "^${disk}" /proc/mounts | cut -d ' ' -f 2 | sort -r | while read -r mnt; do
        umount -f "${mnt}" 2>/dev/null || true
    done
    
    # Disable swap if on this disk
    grep "^${disk}" /proc/swaps | cut -d ' ' -f 1 | while read -r swp; do
        swapoff "${swp}" 2>/dev/null || true
    done
}

wipe_disk() {
	local disk=$1

    umount_disk "${disk}"

	log_info "Wiping disk ${disk}..."

	if ! ui_spin "Wiping signatures on ${disk}" wipefs -a "${disk}" 2>>"${LOG_FILE}"; then
		# Try harder with dd if wipefs fails
        log_warn "wipefs failed on ${disk}, trying dd zeroing of partition table area..."
        dd if=/dev/zero of="${disk}" bs=1M count=10 2>>"${LOG_FILE}" || true
        # Retry wipefs
        wipefs -a "${disk}" 2>>"${LOG_FILE}" || error_exit "Failed to wipe disk ${disk}"
	fi

	if ! ui_spin "Zapping GPT on ${disk}" sgdisk --zap-all "${disk}" 2>>"${LOG_FILE}"; then
		error_exit "Failed to execute sgdisk --zap-all on ${disk}"
	fi

	sync
	log_success "Disk ${disk} wiped successfully"
}

# =============================================================================
# PARTITIONING
# =============================================================================

partition_disk() {
	local disk=$1
    local profile_type=${2:-Server}
	local part_suffix
	part_suffix=$(get_part_suffix "${disk}")

	log_info "Partitioning disk: ${disk} (Profile: ${profile_type})"

    local esp_size="+256M"
    if [[ "${profile_type}" == "Workstation" ]]; then
        esp_size="+512M"
    fi

	# ESP Configuration
	if ! ui_spin "Creating EFI Partition on ${disk}" sgdisk -n 1:2048:${esp_size} -t 1:EF00 -c 1:'EFI System' "${disk}" 2>>"${LOG_FILE}"; then
		error_exit "Failed to create EFI partition on ${disk}"
	fi
	sgdisk -A 1:set:2 "${disk}" 2>>"${LOG_FILE}" || error_exit "Failed to set Legacy Boot attribute on ESP"

	# ZFS Partition
	if ! ui_spin "Creating ZFS Partition on ${disk}" sgdisk -n 2:0:0 -t 2:BF00 -c 2:'ZFS Root' "${disk}" 2>>"${LOG_FILE}"; then
		error_exit "Failed to create ZFS partition on ${disk}"
	fi

	# Probe
	ui_spin "Probing partitions on ${disk}" partprobe "${disk}" 2>>"${LOG_FILE}" || log_warn "Partprobe failed, but continuing..."

	sync
	log_success "Disk ${disk} partitioned successfully"
}

prepare_disks() {
	log_init_component "Preparing Disks"
	for disk in "${SELECTED_DISKS[@]}"; do
		wipe_disk "${disk}"
		partition_disk "${disk}" "${PROFILE}"
	done
    # Trigger udev to ensure /dev/disk/by-id/ links are updated
    udevadm trigger || true
    udevadm settle || true
	log_end_component "Preparing Disks"
}

# =============================================================================
# ZFS POOL CREATION
# =============================================================================

get_zfs_partitions() {
	local -a zfs_parts=()
	for disk in "${SELECTED_DISKS[@]}"; do
		[[ -z ${disk} ]] && continue
		local part_suffix
		part_suffix=$(get_part_suffix "${disk}")
		zfs_parts+=("${disk}${part_suffix}2")
	done
	echo "${zfs_parts[@]}"
}

get_efi_partition() {
	local disk=${SELECTED_DISKS[0]}
	local part_suffix
	part_suffix=$(get_part_suffix "${disk}")
	echo "${disk}${part_suffix}1"
}

create_pool() {
    log_init_component "Creating ZFS Pool"

    # Gather partitions
    local -a zfs_parts
    read -r -a zfs_parts <<< "$(get_zfs_partitions)"

    if [[ ${#zfs_parts[@]} -eq 0 ]]; then
		error_exit "No ZFS partitions found."
	fi

    # Clear labels
    for part in "${zfs_parts[@]}"; do
		zpool labelclear -f "${part}" 2>>"${LOG_FILE}" || true
	done

    # Build command
    local pool_cmd=(
		zpool create -f
		-o "ashift=${ASHIFT}"
		-o autotrim=on
		-O acltype=posixacl
		-O canmount=off
		-O "compression=${COMPRESSION}"
		-O dnodesize=auto
		-O normalization=formD
		-O relatime=on
		-O xattr=sa
		-O mountpoint=none
		-O "checksum=${CHECKSUM}"
		-O "copies=${COPIES}"
		-R "${MOUNT_POINT}"
	)

    # Topology
    local -a topology_args=()
	case ${RAID_TOPOLOGY} in
	Single) topology_args+=("${POOL_NAME}" "${zfs_parts[0]}") ;;
	Stripe) topology_args+=("${POOL_NAME}" "${zfs_parts[@]}") ;;
	Mirror) topology_args+=("${POOL_NAME}" mirror "${zfs_parts[@]}") ;;
	RAIDZ1) topology_args+=("${POOL_NAME}" raidz1 "${zfs_parts[@]}") ;;
	RAIDZ2) topology_args+=("${POOL_NAME}" raidz2 "${zfs_parts[@]}") ;;
	RAIDZ3) topology_args+=("${POOL_NAME}" raidz3 "${zfs_parts[@]}") ;;
	*) topology_args+=("${POOL_NAME}" "${zfs_parts[0]}") ;;
	esac

    # Encryption?
    if [[ ${ENCRYPTION} == "on" ]]; then
        pool_cmd+=(-O encryption=aes-256-gcm -O keyformat=passphrase -O keylocation=prompt)
        if ! echo "${ENCRYPTION_PASSPHRASE}" | "${pool_cmd[@]}" "${topology_args[@]}" 2>>"${LOG_FILE}"; then
			error_exit "Failed to create encrypted ZFS pool."
		fi
    else
        if ! "${pool_cmd[@]}" "${topology_args[@]}" 2>>"${LOG_FILE}"; then
			error_exit "Failed to create ZFS pool."
		fi
    fi

    # Cache file
    zpool set cachefile=/etc/zfs/zpool.cache "${POOL_NAME}" 2>>"${LOG_FILE}" || true
    
    log_success "ZFS Pool created: ${POOL_NAME}"
}

# =============================================================================
# DATASETS
# =============================================================================

create_datasets() {
    log_init_component "Creating Datasets (${PROFILE})"
    local pool="${POOL_NAME}"

    # Base Datasets
    zfs create -o canmount=off -o mountpoint=none -o acltype=posixacl -o xattr=sa -o aclinherit=passthrough "${pool}/ROOT"
    zfs create -o canmount=noauto -o mountpoint=/ -o com.sun:auto-snapshot=true "${pool}/ROOT/debian"
    zfs create -o mountpoint=/var -o canmount=off "${pool}/var"

    # Profile Specifics
    if [[ "${PROFILE}" == "Server" ]]; then
        zfs create -o mountpoint=/home -o com.sun:auto-snapshot=false "${pool}/home"
        zfs create -o mountpoint=/root "${pool}/home/root"
        zfs create -o mountpoint=/var/log -o compression=zstd -o atime=off "${pool}/var/log"
        zfs create -o mountpoint=/var/cache -o compression=lz4 -o atime=off "${pool}/var/cache"
        zfs create -o mountpoint=/srv -o compression=lz4 -o atime=off "${pool}/srv"
    else
        # Workstation / Default
        zfs create -o mountpoint=/home -o com.sun:auto-snapshot=true "${pool}/home"
        zfs create -o mountpoint=/home/user -o com.sun:auto-snapshot=true "${pool}/home/user"
        zfs create -o mountpoint=/root "${pool}/home/root"
        zfs create -o mountpoint=/var/log -o compression=lz4 "${pool}/var/log"
        zfs create -o mountpoint=/var/cache -o compression=lz4 "${pool}/var/cache"
    fi
    
    # Common
    zfs create -o com.sun:auto-snapshot=false "${pool}/var/tmp"

    # Boot Config
    zfs set org.zfsbootmenu:commandline="quiet" "${pool}/ROOT/debian"
    zpool set bootfs="${pool}/ROOT/debian" "${pool}"

    log_success "Datasets created"
}

# =============================================================================
# EXTRACTION
# =============================================================================

extract_system() {
    log_init_component "System Extraction"
    
    mkdir -p "${MOUNT_POINT}"/{dev,proc,sys,run,tmp}
    chmod 1777 "${MOUNT_POINT}/tmp"

    # Find squashfs
    local squashfs_path=""
    for path in "/run/live/medium/live/00-core.squashfs" "/cdrom/live/00-core.squashfs" "/lib/live/mount/medium/live/00-core.squashfs"; do
        if [[ -f ${path} ]]; then squashfs_path="${path}"; break; fi
    done

    if [[ -z ${squashfs_path} ]]; then
        error_exit "Squashfs not found!"
    fi
    log_info "Using squashfs: ${squashfs_path}"

    # Extract
    if ! unsquashfs -f -n -d "${MOUNT_POINT}" "${squashfs_path}" > "${LOG_FILE}.extract" 2>&1; then
        cat "${LOG_FILE}.extract" >> "${LOG_FILE}"
        error_exit "Squashfs extraction failed"
    fi

    # Zpool cache copy
    mkdir -p "${MOUNT_POINT}/etc/zfs"
    cp /etc/zfs/zpool.cache "${MOUNT_POINT}/etc/zfs/" 2>/dev/null || true

    log_success "System extracted"
}

# =============================================================================
# CONFIGURATION (CHROOT)
# =============================================================================

configure_system() {
    log_init_component "System Configuration"
    
    # Hostname, Hosts, Users, Locale, Timezone, Fstab, Initramfs
    echo "${HOSTNAME}" > "${MOUNT_POINT}/etc/hostname"
    
    cat > "${MOUNT_POINT}/etc/hosts" <<EOF
127.0.0.1 localhost
127.0.1.1 ${HOSTNAME}
::1 localhost ip6-localhost ip6-loopback
EOF

    # Users
    chroot_zfs "${MOUNT_POINT}" /bin/bash -c "echo 'root:${ROOT_PASS}' | chpasswd"
    chroot_zfs "${MOUNT_POINT}" useradd -m -s /bin/bash -G sudo,dip,plugdev,cdrom "${USERNAME}"
    chroot_zfs "${MOUNT_POINT}" /bin/bash -c "echo '${USERNAME}:${USER_PASS}' | chpasswd"
    echo "${USERNAME} ALL=(ALL) NOPASSWD: ALL" > "${MOUNT_POINT}/etc/sudoers.d/${USERNAME}"

    # Fstab
    cat > "${MOUNT_POINT}/etc/fstab" <<EOF
${POOL_NAME}/ROOT/debian / zfs defaults,noatime,xattr=sa 0 0
${POOL_NAME}/home /home zfs defaults,noatime,xattr=sa 0 0
${POOL_NAME}/home/root /root zfs defaults,noatime,xattr=sa 0 0
${POOL_NAME}/var/log /var/log zfs defaults,noatime,xattr=sa 0 0
${POOL_NAME}/var/cache /var/cache zfs defaults,noatime,xattr=sa 0 0
tmpfs /tmp tmpfs defaults,nosuid,nodev,noexec,mode=1777 0 0
EOF

    # HostID
    chroot_zfs "${MOUNT_POINT}" zgenhostid

    # Initramfs & Kernel pinning
    cat > "${MOUNT_POINT}/etc/apt/preferences.d/zfs-kernel-pin.pref" <<EOF
Package: linux-image-amd64 linux-headers-amd64
Pin: release n=trixie
Pin-Priority: 900
EOF

    # ZFS systemd targets
    chroot_zfs "${MOUNT_POINT}" systemctl enable zfs.target zfs-import-cache zfs-mount zfs-import.target || true
    chroot_zfs "${MOUNT_POINT}" update-initramfs -c -k all

    log_success "System Configured"
}

# =============================================================================
# BOOTLOADER
# =============================================================================

install_bootloader() {
    log_init_component "Installing Bootloader"
    
    local disk=${SELECTED_DISKS[0]}
    local part_suffix=$(get_part_suffix "${disk}")
    local efi_part="${disk}${part_suffix}1"

    # Format ESP
    mkfs.vfat -F32 "${efi_part}" 2>>"${LOG_FILE}" || error_exit "Failed to format ESP"
    
    mkdir -p "${MOUNT_POINT}/boot/efi"
    mount "${efi_part}" "${MOUNT_POINT}/boot/efi"
    mkdir -p "${MOUNT_POINT}/boot/efi/EFI/"{ZBM,BOOT}

    # Install ZBM
    local zbm_src="/usr/share/zfsbootmenu/VMLINUZ.EFI"
    if [[ -f ${zbm_src} ]]; then
        cp "${zbm_src}" "${MOUNT_POINT}/boot/efi/EFI/ZBM/VMLINUZ.EFI"
        cp "${zbm_src}" "${MOUNT_POINT}/boot/efi/EFI/BOOT/BOOTX64.EFI"
        
        # EFIBootMgr
        if command -v efibootmgr >/dev/null; then
             efibootmgr -c -d "${disk}" -p 1 -L "ZFSBootMenu" -l '\EFI\ZBM\VMLINUZ.EFI' || true
        fi
    else
        log_warn "ZFSBootMenu binary not found at ${zbm_src}, skipping copy."
    fi

    log_success "Bootloader Installed"
}

# =============================================================================
# MAIN UI FLOW
# =============================================================================

select_disks() {
    local disks_raw
    disks_raw=$(lsblk -d -n -o NAME,SIZE,MODEL -e 7,11)
    
    if [[ -z ${disks_raw} ]]; then error_exit "No disks found"; fi

    local disks_fmt
    disks_fmt=$(echo "${disks_raw}" | awk '{printf "/dev/%s (%s - %s)\n", $1, $2, substr($0, index($0,$3))}')
    mapfile -t disks_list <<<"${disks_fmt}"

    local raw_selection
    if ! raw_selection=$(ui_choose_multi "Select Target Disk(s):" "${disks_list[@]}"); then
        exit 0
    fi

    SELECTED_DISKS=()
    while IFS= read -r sel; do
        [[ -z ${sel} ]] && continue
        local dev
        dev=$(echo "${sel}" | awk '{print $1}')
        if [[ -b ${dev} ]]; then SELECTED_DISKS+=("${dev}"); fi
    done <<<"${raw_selection}"

    if [[ ${#SELECTED_DISKS[@]} -eq 0 ]]; then error_exit "Invalid selection"; fi
}

input_user_info() {
    HOSTNAME=$(ui_input "Hostname" "DEBIAN_ZFS" "DEBIAN_ZFS")
    PROFILE=$(ui_choose "Profile" "Server" "Workstation")
    ROOT_PASS=$(ui_input "Root Password" "" "" "true")
    USERNAME=$(ui_input "New User" "admin" "admin")
    USER_PASS=$(ui_input "User Password" "" "" "true")
    
    if [[ ${#SELECTED_DISKS[@]} -gt 1 ]]; then
        RAID_TOPOLOGY=$(ui_choose "Topology" "Mirror" "RAIDZ1" "Stripe")
    else
        RAID_TOPOLOGY="Single"
    fi
}

main() {
    if [[ ${EUID} -ne 0 ]]; then echo "Root required"; exit 1; fi
    
    log_init
    check_dependencies

    ui_header "DEBIAN ZFS CONSOLIDATED" "Debian Trixie Installer"
    
    select_disks
    input_user_info
    
    if ! ui_confirm "ERASE ALL DATA on ${SELECTED_DISKS[*]} and install?"; then exit 0; fi

    prepare_disks
    create_pool
    create_datasets
    extract_system
    configure_system
    install_bootloader
    
    # Cleanup
    umount -l "${MOUNT_POINT}/boot/efi" || true
    zfs umount -a || true
    zpool export "${POOL_NAME}" || true
    
    ui_alert "SUCCESS" "Installation Complete!" "success"
}

main "$@"
