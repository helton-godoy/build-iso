#!/usr/bin/env bash
#
# install-system - Instalador Debian ZFS (Orquestrador Principal)
# Debian + ZFS-on-Root + ZFSBootMenu
#
# [commit] feat: orquestrador principal do instalador com suporte a perfis e ui_gum
#
# Uso: sudo install-system
#

set -euo pipefail

# =============================================================================
# VARI√ÅVEIS GLOBAIS
# =============================================================================

# Caminhos absolutos (FHS-like)
readonly INSTALLER_DIR="/usr/local/bin/installer"
readonly LIB_DIR="${INSTALLER_DIR}/lib"
readonly COMPONENTS_DIR="${INSTALLER_DIR}/components"
export LIB_DIR INSTALLER_DIR COMPONENTS_DIR

source "${LIB_DIR}/logging.sh"
source "${LIB_DIR}/validation.sh"
source "${LIB_DIR}/error.sh"
source "${LIB_DIR}/ui_gum.sh"

section_header() {
	echo ""
	echo "‚îÄ‚îÄ‚îÄ $1 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
}

# Vari√°veis globais para componentes
declare PROFILE="${PROFILE:-Server}"
declare POOL_NAME="zroot"
declare MOUNT_POINT="${MOUNT_POINT:-/mnt/target}"
declare RAID_TOPOLOGY=""
declare ASHIFT=12
declare COMPRESSION="zstd"
declare CHECKSUM="on"
declare COPIES=1
declare HDSIZE=""
declare ENCRYPTION="off"
declare ENCRYPTION_PASSPHRASE=""

# Vari√°veis de usu√°rio (ser√£o populados)
declare HOSTNAME=""
declare USERNAME=""
declare ROOT_PASS=""
declare USER_PASS=""

# Lista de componentes em ordem de execu√ß√£o
declare -a COMPONENTS=(
	"components/01-validate.sh"
	"components/02-partition.sh"
	"components/03-pool.sh"
	"components/04-datasets.sh"
	"components/05-extract.sh"
	"components/06-chroot-configure.sh"
	"components/07-bootloader.sh"
	"components/08-cleanup.sh"
)

# =============================================================================
# FUN√á√ïES DE INTERFACE DO USU√ÅRIO
# =============================================================================

# Screen de boas-vindas com DEBIAN_ZFS
# Screen de boas-vindas com DEBIAN_ZFS
welcome_screen() {
	if [[ -z ${GUM_BIN-} ]]; then
		log_warn "UI Lib not loaded correctly?"
	fi

	# Clear screen for fresh start
	clear

	ui_header "DEBIAN_ZFS Installer" "Debian Trixie + ZFS-on-Root + ZFSBootMenu"

	local sys_info
	sys_info=$(uname -r)
	local date_info
	date_info=$(date "+%Y-%m-%d %H:%M")

	"${GUM_BIN}" style \
		--align center \
		--foreground "${GUM_COLOR_SUBTEXT}" \
		"Kernel: ${sys_info} | Date: ${date_info}" ""

	# Show warning via alert
	ui_alert "‚ö†Ô∏è  DESTRUCTIVE ACTION" \
		"This installer will permanently ERASE selected disks.\nEnsure you have backups before proceeding." "error"

	if ! ui_confirm "Ready to start the installation journey?"; then
		log_info "Instala√ß√£o cancelada pelo usu√°rio"
		exit 0
	fi

	log_info "Iniciando instala√ß√£o DEBIAN_ZFS..."
}

# Selecionar disco(s)
select_disks() {
	local disks_raw disks_table disks_list
	section_header "Disks Selection"

	# Listar discos dispon√≠veis
	disks_raw=$(lsblk -d -n -o NAME,SIZE,MODEL -e 7,11)

	if [[ -z ${disks_raw} ]]; then
		log_error "Nenhum disco adequado encontrado"
		ui_alert "Critical Error" "No suitable disks found for installation." "error"
		exit 1
	fi

	# Preparar tabela para visualiza√ß√£o
	disks_table=$(echo "${disks_raw}" | awk '{print $1 "," $2 "," substr($0, index($0,$3))}')

	log_info "Discos detectados no sistema:"
	ui_table "Device,Size,Model" "${disks_table}"

	# Preparar lista para o gum choose
	mapfile -t disks_list < <(echo "${disks_raw}" | awk '{printf "/dev/%s (%s - %s)\n", $1, $2, substr($0, index($0,$3))}')

	# Sele√ß√£o com checkbox via gum
	local raw_selection
	if ! raw_selection=$(ui_choose_multi "Select Target Disk(s):" "${disks_list[@]}"); then
		log_error "Sele√ß√£o de discos cancelada pelo usu√°rio"
		exit 0
	fi

	# Processar cada linha selecionada
	declare -a selected_disks=()
	while IFS= read -r sel; do
		[[ -z ${sel} ]] && continue

		# Extrair caminho do dispositivo (pega a primeira palavra, removendo espa√ßos extras)
		local dev
		dev=$(echo "${sel}" | awk '{print $1}')

		if [[ -n ${dev} ]] && [[ -b ${dev} ]]; then
			selected_disks+=("${dev}")
		else
			# Tentar regex como fallback para casos estranhos
			dev=$(echo "${sel}" | grep -oE '/dev/[a-z0-9/]+' | head -n 1 || true)
			if [[ -n ${dev} ]] && [[ -b ${dev} ]]; then
				selected_disks+=("${dev}")
			else
				log_warn "Falha ao extrair dispositivo v√°lido de: '${sel}'"
			fi
		fi
	done <<<"${raw_selection}"

	if [[ ${#selected_disks[@]} -eq 0 ]]; then
		log_error "N√£o foi poss√≠vel identificar dispositivos v√°lidos na sua sele√ß√£o"
		exit 1
	fi

	# Validar discos selecionados e confirmar wipe
	for disk in "${selected_disks[@]}"; do
		# ... logic validation ...
		local size_gb
		size_gb=$(lsblk -b -o SIZE -n -d "${disk}" | awk '{printf "%.0f", $1/1024/1024/1024}')

		if ((size_gb < 20)); then
			log_warn "Disco ${disk} muito pequeno: ${size_gb}GB < 20GB m√≠nimo"
			if ! ui_confirm "Disk ${disk} is small (${size_gb}GB). Continue?"; then
				log_info "Instala√ß√£o cancelada: disco muito pequeno"
				exit 1
			fi
		fi
	done

	# Confirmar destrui√ß√£o
	ui_alert "‚ö†Ô∏è  FINAL WARNING" \
		"ALL DATA on: \n\n${selected_disks[*]} \n\nWILL BE ERASED." "error"

	if ! ui_confirm "Are you absolutely sure?"; then
		log_info "Instala√ß√£o cancelada pelo usu√°rio"
		exit 0
	fi

	log_info "Discos selecionados: ${selected_disks[*]}"

	# Exportar vari√°veis globais para uso dos componentes
	SELECTED_DISKS=("${selected_disks[@]}")
	export SELECTED_DISKS
}

# Coletar informa√ß√µes do sistema (hostname, usu√°rios, etc)
collect_system_info() {
	section_header "System Identity"

	# Hostname
	HOSTNAME=$(ui_input "Hostname" "Ex: DEBIAN_ZFS" "DEBIAN_ZFS")

	if [[ -z ${HOSTNAME} ]]; then
		log_error "Hostname n√£o pode ser vazio"
		exit 1
	fi

	# Perfil de instala√ß√£o
	PROFILE=$(ui_choose "Select Installation Profile:" "Server" "Workstation" "Minimal")

	log_info "Perfil selecionado: ${PROFILE}"

	# Senhas
	ROOT_PASS=$(ui_input "Root Password" "" "" "true")
	USERNAME=$(ui_input "New User" "Ex: admin" "admin")
	USER_PASS=$(ui_input "User Password (${USERNAME})" "" "" "true")

	# Valida√ß√µes b√°sicas happen here...
	# ... (logic remains) ...
	log_info "Informa√ß√µes do sistema coletadas"
}

# Op√ß√µes ZFS avan√ßadas (opcional - podem ser padronizados)
collect_zfs_options() {
	section_header "ZFS Advanced (Optional)"

	ASHIFT=$(ui_choose "Select ashift (Sector Size):" "12" "9" "13" "14")
	COMPRESSION=$(ui_choose "Select Compression:" "zstd" "lz4" "off" "gzip")
	CHECKSUM=$(ui_choose "Select Checksum:" "on" "off" "sha256")
	COPIES=$(ui_choose "Select Redundancy Copies:" "1" "2" "3")

	# Op√ß√µes de criptografia (s√≥ se dispon√≠vel no kernel)
	if [[ -f "/proc/crypto" ]]; then
		# Check if user wants encryption
		if ui_confirm "Enable Native ZFS Encryption?"; then
			ENCRYPTION="on"
			ENCRYPTION_PASSPHRASE=$(ui_input "ZFS Pool Passphrase" "" "" "true")
			local confirm_pass
			confirm_pass=$(ui_input "Confirm Passphrase" "" "" "true")

			if [[ ${ENCRYPTION_PASSPHRASE} != "${confirm_pass}" ]]; then
				ui_alert "Error" "Passphrases do not match!" "error"
				return 1
			fi
			# ...
		else
			ENCRYPTION="off"
		fi
	fi

	# ...
}

# Selecionar topologia RAID (apenas se m√∫ltiplos discos)
select_topology() {
	local num_disks=${#selected_disks[@]}
	local options=()

	case ${num_disks} in
	1)
		options=("Single")
		;;
	2)
		options=("Mirror" "Stripe")
		;;
	3)
		options=("Mirror" "RAIDZ1" "Stripe")
		;;
	4)
		options=("Mirror" "RAIDZ1" "RAIDZ2" "Stripe")
		;;
	*)
		options=("Mirror" "RAIDZ1" "RAIDZ2" "RAIDZ3" "Stripe")
		;;
	esac

	RAID_TOPOLOGY=$(ui_choose "Select RAID Topology:" "${options[@]}")
	log_info "Topologia selecionada: ${RAID_TOPOLOGY}"
}

# Resumo final antes de iniciar
show_installation_summary() {
	if [[ -z ${GUM_BIN-} ]]; then
		log_warn "UI Lib not loaded correctly?"
	fi

	local summary_text
	summary_text="$(
		cat <<EOF
**üåç GENERAL**
 ‚Ä¢ Disks:      ${SELECTED_DISKS[*]}
 ‚Ä¢ Topology:   ${RAID_TOPOLOGY}
 ‚Ä¢ Hostname:   ${HOSTNAME}
 ‚Ä¢ Profile:    ${PROFILE}
 ‚Ä¢ User:       ${USERNAME}

**‚ö° ZFS CONFIG**
 ‚Ä¢ Pool:       ${POOL_NAME}
 ‚Ä¢ A-Shift:    ${ASHIFT}
 ‚Ä¢ Compress:   ${COMPRESSION}
 ‚Ä¢ Checksum:   ${CHECKSUM}
 ‚Ä¢ Copies:     ${COPIES}
 ‚Ä¢ Encryption: ${ENCRYPTION}
EOF
	)"

	# Display summary
	ui_alert "INSTALLATION SUMMARY" "${summary_text}" "info"

	if ! ui_confirm "Settings correct? Start Installation?"; then
		log_info "Instala√ß√£o cancelada pelo usu√°rio"
		exit 0
	fi
}

# Executar componentes da instala√ß√£o
execute_components() {
	section_header "Installation Progress"

	for component in "${COMPONENTS[@]}"; do
		local script="${INSTALLER_DIR}/${component}"

		if [[ ! -f "${script}" ]]; then
			log_error "Componente n√£o encontrado: ${script}"
			return 1
		fi

		# Torna execut√°vel se n√£o for
		chmod +x "${script}"

		log_info "Executando componente: $(basename "${component}")"

		# Executa o componente
		# As vari√°veis globais (SELECTED_DISKS, PROFILE, etc) j√° foram exportadas
		if ! "${script}"; then
			log_error "Componente $(basename "${component}") falhou."
			return 1
		fi
	done

	return 0
}

# =============================================================================
# FUN√á√ÉO PRINCIPAL
# =============================================================================

main() {
	# Verificar se est√° rodando como root
	if [[ ${EUID} -ne 0 ]]; then
		echo "Root required."
		exit 1
	fi

	# Verificar m√≥dulo ZFS
	if [[ ! -d /sys/module/zfs ]] && ! grep -qw "^zfs " /proc/modules; then
		echo "ZFS Invalid."
		exit 1
	fi

	# Inicializar logging
	log_init

	# Carregar UI (redundant if sourced, but safe)
	if [[ -f "${LIB_DIR}/ui_gum.sh" ]]; then
		source "${LIB_DIR}/ui_gum.sh"
	fi

	set_error_trap

	# Exibir tela de boas-vindas
	welcome_screen

	# Selecionar disco(s)
	select_disks

	# Coletar informa√ß√µes do sistema
	collect_system_info

	# Op√ß√µes ZFS avan√ßadas (opcional)
	collect_zfs_options

	# Selecionar topologia RAID (se aplic√°vel)
	if [[ ${#SELECTED_DISKS[@]} -gt 1 ]]; then
		select_topology
	fi

	# Resumo antes de iniciar
	show_installation_summary

	# Executar todos componentes sequencialmente
	if ! execute_components; then
		log_error "Instala√ß√£o falhou"
		exit 1
	fi

	# Tudo concluido
	ui_alert "SUCCESS" "Installation Completed Successfully!\n\nSystem is ready to reboot." "success"

	log_info "Instalacao concluida com sucesso"
	sync
	log_info 'Aguardando log em ${LOG_FILE}'

	if ui_confirm "Reboot now?"; then
		reboot
	fi

	exit 0
}

# Executar main se script for executado diretamente
if [[ ${BASH_SOURCE[0]} == "${0}" ]]; then
	main "$@"
fi
